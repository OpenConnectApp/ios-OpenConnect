// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: private_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum PrivateDataService_ConnectExchangeResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case connectExchangeSuccess // = 0
  case connectExchangeFailed // = 1
  case connectExchangeAlreadyExists // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .connectExchangeSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .connectExchangeSuccess
    case 1: self = .connectExchangeFailed
    case 2: self = .connectExchangeAlreadyExists
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .connectExchangeSuccess: return 0
    case .connectExchangeFailed: return 1
    case .connectExchangeAlreadyExists: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_ConnectExchangeResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_ConnectExchangeResponseCodes] = [
    .connectExchangeSuccess,
    .connectExchangeFailed,
    .connectExchangeAlreadyExists,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_DisconnectExchangeResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case disconnectExchangeSuccess // = 0
  case disconnectExchangeFailed // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .disconnectExchangeSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disconnectExchangeSuccess
    case 1: self = .disconnectExchangeFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .disconnectExchangeSuccess: return 0
    case .disconnectExchangeFailed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_DisconnectExchangeResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_DisconnectExchangeResponseCodes] = [
    .disconnectExchangeSuccess,
    .disconnectExchangeFailed,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_GetExchangeStatusResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case getExchangeStatusSuccess // = 0
  case getExchangeStatusFailed // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .getExchangeStatusSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getExchangeStatusSuccess
    case 1: self = .getExchangeStatusFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .getExchangeStatusSuccess: return 0
    case .getExchangeStatusFailed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_GetExchangeStatusResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_GetExchangeStatusResponseCodes] = [
    .getExchangeStatusSuccess,
    .getExchangeStatusFailed,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_ListConnectedExchangesSortBy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case exchangeID // = 0
  case portfolioName // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .exchangeID
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .exchangeID
    case 1: self = .portfolioName
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .exchangeID: return 0
    case .portfolioName: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_ListConnectedExchangesSortBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_ListConnectedExchangesSortBy] = [
    .exchangeID,
    .portfolioName,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_ListConnectedExchangesResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case listConnectedExchangesSuccess // = 0
  case listConnectedExchangesFailed // = 1
  case listConnectedExchangesNoContent // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .listConnectedExchangesSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .listConnectedExchangesSuccess
    case 1: self = .listConnectedExchangesFailed
    case 2: self = .listConnectedExchangesNoContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .listConnectedExchangesSuccess: return 0
    case .listConnectedExchangesFailed: return 1
    case .listConnectedExchangesNoContent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_ListConnectedExchangesResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_ListConnectedExchangesResponseCodes] = [
    .listConnectedExchangesSuccess,
    .listConnectedExchangesFailed,
    .listConnectedExchangesNoContent,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_TransactionTypes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case buy // = 0
  case sell // = 1
  case deposit // = 2
  case withdrawal // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .buy
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .buy
    case 1: self = .sell
    case 2: self = .deposit
    case 3: self = .withdrawal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .buy: return 0
    case .sell: return 1
    case .deposit: return 2
    case .withdrawal: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_TransactionTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_TransactionTypes] = [
    .buy,
    .sell,
    .deposit,
    .withdrawal,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_Duration: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case h1 // = 0
  case h24 // = 1
  case d7 // = 2
  case d30 // = 3
  case d90 // = 4
  case y1 // = 5
  case all // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .h1
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .h1
    case 1: self = .h24
    case 2: self = .d7
    case 3: self = .d30
    case 4: self = .d90
    case 5: self = .y1
    case 6: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .h1: return 0
    case .h24: return 1
    case .d7: return 2
    case .d30: return 3
    case .d90: return 4
    case .y1: return 5
    case .all: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_Duration: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_Duration] = [
    .h1,
    .h24,
    .d7,
    .d30,
    .d90,
    .y1,
    .all,
  ]
}

#endif  // swift(>=4.2)

public enum PrivateDataService_GetTransactionsResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case getTransactionsResponseSuccess // = 0
  case getTransactionsResponseFailed // = 1
  case getTransactionsResponseNoContent // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .getTransactionsResponseSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getTransactionsResponseSuccess
    case 1: self = .getTransactionsResponseFailed
    case 2: self = .getTransactionsResponseNoContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .getTransactionsResponseSuccess: return 0
    case .getTransactionsResponseFailed: return 1
    case .getTransactionsResponseNoContent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PrivateDataService_GetTransactionsResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PrivateDataService_GetTransactionsResponseCodes] = [
    .getTransactionsResponseSuccess,
    .getTransactionsResponseFailed,
    .getTransactionsResponseNoContent,
  ]
}

#endif  // swift(>=4.2)

public struct PrivateDataService_ConnectExchangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var portfolioName: String = String()

  public var apiKey: String = String()

  public var apiSecret: String = String()

  public var importTransactions: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_ConnectExchangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PrivateDataService_ConnectExchangeResponseCodes = .connectExchangeSuccess

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_DisconnectExchangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_DisconnectExchangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PrivateDataService_DisconnectExchangeResponseCodes = .disconnectExchangeSuccess

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_GetExchangeStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_GetExchangeStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PrivateDataService_GetExchangeStatusResponseCodes = .getExchangeStatusSuccess

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_ListConnectedExchangesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var portfolioName: String = String()

  public var sortBy: PrivateDataService_ListConnectedExchangesSortBy = .exchangeID

  public var orderBy: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_ConnectedExchange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var portfolioName: String = String()

  public var apiKey: String = String()

  public var apiSecret: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_ListConnectedExchangesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PrivateDataService_ListConnectedExchangesResponseCodes = .listConnectedExchangesSuccess

  public var message: String = String()

  public var data: [PrivateDataService_ConnectedExchange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_GetTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: PrivateDataService_TransactionTypes = .buy

  public var duration: PrivateDataService_Duration = .h1

  public var timeStart: String = String()

  public var timeEnd: String = String()

  public var currencyID: String = String()

  public var name: String = String()

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: PrivateDataService_TransactionTypes = .buy

  public var duration: PrivateDataService_Duration = .h1

  public var timestamp: String = String()

  public var currencyID: String = String()

  public var name: String = String()

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PrivateDataService_GetTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PrivateDataService_GetTransactionsResponseCodes = .getTransactionsResponseSuccess

  public var message: String = String()

  public var data: [PrivateDataService_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "private_data_service"

extension PrivateDataService_ConnectExchangeResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ConnectExchangeSuccess"),
    1: .same(proto: "ConnectExchangeFailed"),
    2: .same(proto: "ConnectExchangeAlreadyExists"),
  ]
}

extension PrivateDataService_DisconnectExchangeResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DisconnectExchangeSuccess"),
    1: .same(proto: "DisconnectExchangeFailed"),
  ]
}

extension PrivateDataService_GetExchangeStatusResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GetExchangeStatusSuccess"),
    1: .same(proto: "GetExchangeStatusFailed"),
  ]
}

extension PrivateDataService_ListConnectedExchangesSortBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "exchange_id"),
    1: .same(proto: "portfolio_name"),
  ]
}

extension PrivateDataService_ListConnectedExchangesResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ListConnectedExchangesSuccess"),
    1: .same(proto: "ListConnectedExchangesFailed"),
    2: .same(proto: "ListConnectedExchangesNoContent"),
  ]
}

extension PrivateDataService_TransactionTypes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Buy"),
    1: .same(proto: "Sell"),
    2: .same(proto: "Deposit"),
    3: .same(proto: "Withdrawal"),
  ]
}

extension PrivateDataService_Duration: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "H1"),
    1: .same(proto: "H24"),
    2: .same(proto: "D7"),
    3: .same(proto: "D30"),
    4: .same(proto: "D90"),
    5: .same(proto: "Y1"),
    6: .same(proto: "All"),
  ]
}

extension PrivateDataService_GetTransactionsResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GetTransactionsResponseSuccess"),
    1: .same(proto: "GetTransactionsResponseFailed"),
    2: .same(proto: "GetTransactionsResponseNoContent"),
  ]
}

extension PrivateDataService_ConnectExchangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectExchangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "portfolio_name"),
    3: .standard(proto: "api_key"),
    4: .standard(proto: "api_secret"),
    5: .standard(proto: "import_transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.portfolioName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.apiSecret) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.importTransactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.portfolioName.isEmpty {
      try visitor.visitSingularStringField(value: self.portfolioName, fieldNumber: 2)
    }
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 3)
    }
    if !self.apiSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.apiSecret, fieldNumber: 4)
    }
    if self.importTransactions != false {
      try visitor.visitSingularBoolField(value: self.importTransactions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_ConnectExchangeRequest, rhs: PrivateDataService_ConnectExchangeRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.portfolioName != rhs.portfolioName {return false}
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs.apiSecret != rhs.apiSecret {return false}
    if lhs.importTransactions != rhs.importTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_ConnectExchangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectExchangeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .connectExchangeSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_ConnectExchangeResponse, rhs: PrivateDataService_ConnectExchangeResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_DisconnectExchangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectExchangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_DisconnectExchangeRequest, rhs: PrivateDataService_DisconnectExchangeRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_DisconnectExchangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectExchangeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .disconnectExchangeSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_DisconnectExchangeResponse, rhs: PrivateDataService_DisconnectExchangeResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_GetExchangeStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetExchangeStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_GetExchangeStatusRequest, rhs: PrivateDataService_GetExchangeStatusRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_GetExchangeStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetExchangeStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .getExchangeStatusSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_GetExchangeStatusResponse, rhs: PrivateDataService_GetExchangeStatusResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_ListConnectedExchangesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConnectedExchangesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "portfolio_name"),
    7: .standard(proto: "sort_by"),
    8: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.portfolioName) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.portfolioName.isEmpty {
      try visitor.visitSingularStringField(value: self.portfolioName, fieldNumber: 2)
    }
    if self.sortBy != .exchangeID {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 7)
    }
    if self.orderBy != false {
      try visitor.visitSingularBoolField(value: self.orderBy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_ListConnectedExchangesRequest, rhs: PrivateDataService_ListConnectedExchangesRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.portfolioName != rhs.portfolioName {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_ConnectedExchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectedExchange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "portfolio_name"),
    3: .standard(proto: "api_key"),
    4: .standard(proto: "api_secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.portfolioName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.apiSecret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.portfolioName.isEmpty {
      try visitor.visitSingularStringField(value: self.portfolioName, fieldNumber: 2)
    }
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 3)
    }
    if !self.apiSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.apiSecret, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_ConnectedExchange, rhs: PrivateDataService_ConnectedExchange) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.portfolioName != rhs.portfolioName {return false}
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs.apiSecret != rhs.apiSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_ListConnectedExchangesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConnectedExchangesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .listConnectedExchangesSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_ListConnectedExchangesResponse, rhs: PrivateDataService_ListConnectedExchangesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_GetTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTransactionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "duration"),
    3: .standard(proto: "time_start"),
    4: .standard(proto: "time_end"),
    5: .standard(proto: "currency_id"),
    6: .same(proto: "name"),
    7: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeStart) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.timeEnd) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .buy {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.duration != .h1 {
      try visitor.visitSingularEnumField(value: self.duration, fieldNumber: 2)
    }
    if !self.timeStart.isEmpty {
      try visitor.visitSingularStringField(value: self.timeStart, fieldNumber: 3)
    }
    if !self.timeEnd.isEmpty {
      try visitor.visitSingularStringField(value: self.timeEnd, fieldNumber: 4)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_GetTransactionsRequest, rhs: PrivateDataService_GetTransactionsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.timeStart != rhs.timeStart {return false}
    if lhs.timeEnd != rhs.timeEnd {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "duration"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "currency_id"),
    5: .same(proto: "name"),
    6: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .buy {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.duration != .h1 {
      try visitor.visitSingularEnumField(value: self.duration, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 3)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_Transaction, rhs: PrivateDataService_Transaction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PrivateDataService_GetTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTransactionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .getTransactionsResponseSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PrivateDataService_GetTransactionsResponse, rhs: PrivateDataService_GetTransactionsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
