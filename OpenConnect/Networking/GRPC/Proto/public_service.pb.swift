// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: public_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum PublicDataService_ListExchangesRequestSortByFields: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case exchangeID // = 0
  case exchangeName // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .exchangeID
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .exchangeID
    case 1: self = .exchangeName
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .exchangeID: return 0
    case .exchangeName: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicDataService_ListExchangesRequestSortByFields: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PublicDataService_ListExchangesRequestSortByFields] = [
    .exchangeID,
    .exchangeName,
  ]
}

#endif  // swift(>=4.2)

public enum PublicDataService_ListExchangesResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case listExchangeSuccess // = 0
  case listExchangeFailed // = 1
  case listExchangeNoContent // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .listExchangeSuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .listExchangeSuccess
    case 1: self = .listExchangeFailed
    case 2: self = .listExchangeNoContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .listExchangeSuccess: return 0
    case .listExchangeFailed: return 1
    case .listExchangeNoContent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicDataService_ListExchangesResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PublicDataService_ListExchangesResponseCodes] = [
    .listExchangeSuccess,
    .listExchangeFailed,
    .listExchangeNoContent,
  ]
}

#endif  // swift(>=4.2)

public enum PublicDataService_ListCurrenciesSortBy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case currencyID // = 0
  case name // = 1
  case value // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .currencyID
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .currencyID
    case 1: self = .name
    case 2: self = .value
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .currencyID: return 0
    case .name: return 1
    case .value: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicDataService_ListCurrenciesSortBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PublicDataService_ListCurrenciesSortBy] = [
    .currencyID,
    .name,
    .value,
  ]
}

#endif  // swift(>=4.2)

public enum PublicDataService_ListCurrenciesResponseCodes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case listCurrencySuccess // = 0
  case listCurrencyFailed // = 1
  case listCurrencyNoContent // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .listCurrencySuccess
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .listCurrencySuccess
    case 1: self = .listCurrencyFailed
    case 2: self = .listCurrencyNoContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .listCurrencySuccess: return 0
    case .listCurrencyFailed: return 1
    case .listCurrencyNoContent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicDataService_ListCurrenciesResponseCodes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PublicDataService_ListCurrenciesResponseCodes] = [
    .listCurrencySuccess,
    .listCurrencyFailed,
    .listCurrencyNoContent,
  ]
}

#endif  // swift(>=4.2)

public struct PublicDataService_ListExchangesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var name: String = String()

  public var sortBy: PublicDataService_ListExchangesRequestSortByFields = .exchangeID

  public var orderBy: Bool = false

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublicDataService_ExchangeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: String = String()

  public var name: String = String()

  public var iconURL: String = String()

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublicDataService_ListExchangesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PublicDataService_ListExchangesResponseCodes = .listExchangeSuccess

  public var message: String = String()

  public var data: [PublicDataService_ExchangeData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublicDataService_ListCurrenciesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var currencyID: String = String()

  public var currencyShortCode: String = String()

  public var name: String = String()

  public var baseCurrency: String = String()

  public var value: Float = 0

  public var sortBy: PublicDataService_ListCurrenciesSortBy = .currencyID

  public var orderBy: Bool = false

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublicDataService_CurrencyData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var currencyID: String = String()

  public var name: String = String()

  public var baseCurrency: String = String()

  public var value: Float = 0

  public var iconURL: String = String()

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublicDataService_ListCurrenciesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: PublicDataService_ListCurrenciesResponseCodes = .listCurrencySuccess

  public var message: String = String()

  public var data: [PublicDataService_CurrencyData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "public_data_service"

extension PublicDataService_ListExchangesRequestSortByFields: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "exchange_id"),
    1: .same(proto: "exchange_name"),
  ]
}

extension PublicDataService_ListExchangesResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ListExchangeSuccess"),
    1: .same(proto: "ListExchangeFailed"),
    2: .same(proto: "ListExchangeNoContent"),
  ]
}

extension PublicDataService_ListCurrenciesSortBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CurrencyId"),
    1: .same(proto: "Name"),
    2: .same(proto: "Value"),
  ]
}

extension PublicDataService_ListCurrenciesResponseCodes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ListCurrencySuccess"),
    1: .same(proto: "ListCurrencyFailed"),
    2: .same(proto: "ListCurrencyNoContent"),
  ]
}

extension PublicDataService_ListExchangesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListExchangesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "sort_by"),
    4: .standard(proto: "order_by"),
    5: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.sortBy != .exchangeID {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 3)
    }
    if self.orderBy != false {
      try visitor.visitSingularBoolField(value: self.orderBy, fieldNumber: 4)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_ListExchangesRequest, rhs: PublicDataService_ListExchangesRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicDataService_ExchangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "icon_url"),
    4: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 3)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_ExchangeData, rhs: PublicDataService_ExchangeData) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicDataService_ListExchangesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListExchangesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .listExchangeSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_ListExchangesResponse, rhs: PublicDataService_ListExchangesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicDataService_ListCurrenciesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCurrenciesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_id"),
    2: .standard(proto: "currency_short_code"),
    3: .same(proto: "name"),
    5: .standard(proto: "base_currency"),
    6: .same(proto: "value"),
    7: .standard(proto: "sort_by"),
    8: .standard(proto: "order_by"),
    9: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyShortCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.baseCurrency) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.orderBy) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 1)
    }
    if !self.currencyShortCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyShortCode, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.baseCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCurrency, fieldNumber: 5)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 6)
    }
    if self.sortBy != .currencyID {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 7)
    }
    if self.orderBy != false {
      try visitor.visitSingularBoolField(value: self.orderBy, fieldNumber: 8)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_ListCurrenciesRequest, rhs: PublicDataService_ListCurrenciesRequest) -> Bool {
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.currencyShortCode != rhs.currencyShortCode {return false}
    if lhs.name != rhs.name {return false}
    if lhs.baseCurrency != rhs.baseCurrency {return false}
    if lhs.value != rhs.value {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicDataService_CurrencyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrencyData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "base_currency"),
    4: .same(proto: "value"),
    5: .standard(proto: "icon_url"),
    6: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseCurrency) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.baseCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCurrency, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 5)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_CurrencyData, rhs: PublicDataService_CurrencyData) -> Bool {
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.baseCurrency != rhs.baseCurrency {return false}
    if lhs.value != rhs.value {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicDataService_ListCurrenciesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCurrenciesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .listCurrencySuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublicDataService_ListCurrenciesResponse, rhs: PublicDataService_ListCurrenciesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
